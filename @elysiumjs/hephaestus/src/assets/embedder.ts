// Copyright (c) 2026-present Workbud Technologies Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import type { HephaestusConfig } from '../types';

import { relative } from 'node:path';

/**
 * Manifest mapping asset paths to their base64 content and MIME type.
 * @author Axel Nana <axel.nana@workbud.com>
 */
export interface AssetManifest {
	[path: string]: {
		content: string;
		mimeType: string;
	};
}

/**
 * Embeds assets into a generated loader module for use in compiled binaries.
 *
 * For static assets known at development time, prefer Bun's native file embedding:
 * ```typescript
 * import icon from './icon.png' with { type: 'file' };
 * const bytes = await Bun.file(icon).arrayBuffer();
 * ```
 *
 * This class is for dynamic glob-based embedding from config.
 *
 * @author Axel Nana <axel.nana@workbud.com>
 */
export class AssetEmbedder {
	constructor(private config: HephaestusConfig) {}

	/**
	 * Scans for assets matching the config patterns and generates a loader module.
	 * @author Axel Nana <axel.nana@workbud.com>
	 * @returns A string containing the generated asset loader module.
	 */
	public async embed(): Promise<string> {
		const manifest = await this.buildManifest();
		return this.generateLoader(manifest);
	}

	private async buildManifest(): Promise<AssetManifest> {
		const manifest: AssetManifest = {};
		const patterns = this.config.assets.embed;

		for (const pattern of patterns) {
			// Use Bun.Glob instead of npm glob
			const glob = new Bun.Glob(pattern);

			for await (const file of glob.scan({
				cwd: process.cwd(),
				absolute: true
			})) {
				if (this.isExcluded(file)) continue;

				const content = await Bun.file(file).arrayBuffer();
				const relativePath = relative(process.cwd(), file);

				manifest[relativePath] = {
					content: Buffer.from(content).toString('base64'),
					mimeType: this.getMimeType(file)
				};
			}
		}

		return manifest;
	}

	private isExcluded(filePath: string): boolean {
		return this.config.assets.exclude.some((pattern) => {
			const glob = new Bun.Glob(pattern);
			return glob.match(filePath);
		});
	}

	private generateLoader(manifest: AssetManifest): string {
		return `// Auto-generated by Hephaestus
const __assets__ = ${JSON.stringify(manifest, null, 2)};

export function getAsset(path: string): Buffer | null {
  const asset = __assets__[path];
  if (!asset) return null;
  return Buffer.from(asset.content, 'base64');
}

export function getAssetString(path: string): string | null {
  const buffer = getAsset(path);
  return buffer?.toString('utf-8') ?? null;
}

export function listAssets(): string[] {
  return Object.keys(__assets__);
}
`;
	}

	private getMimeType(path: string): string {
		const ext = path.split('.').pop()?.toLowerCase();
		const mimeTypes: Record<string, string> = {
			html: 'text/html',
			css: 'text/css',
			js: 'application/javascript',
			json: 'application/json',
			png: 'image/png',
			jpg: 'image/jpeg',
			svg: 'image/svg+xml'
		};
		return mimeTypes[ext ?? ''] ?? 'application/octet-stream';
	}
}
